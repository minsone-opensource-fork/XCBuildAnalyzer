//
//  File.swift
//
//
//  Created by Bartosz Polaczyk on 6/19/23.
//

import Foundation
import WebKit
import SwiftUI

public struct GraphKitImage: Hashable {
    var name: String
}
public struct GraphKitNodeId: Hashable {
    var id: String
}

public struct GraphKitNode: Hashable {
    var id: GraphKitNodeId
    var image: GraphKitImage
    var label: String
    var inputs: Set<GraphKitNodeId>
    var outputs: Set<GraphKitNodeId>
    var hasMoreInputs: Bool
    var hasMoreOutputs: Bool
}

public enum GraphKitNodeEvent {
    case click
}

public protocol GraphKitOrchestrator {
    func setGraph(_ nodes: Set<GraphKitNode>)
    func onNodeClick(nodeAction: GraphKitNodeEvent)
}


struct D3PageResponse: Decodable {
    let msg: String
    let id: String
}

public class D3GraphKitOrchestrator : GraphKitOrchestrator {
    var coordinator: D3GraphKitCoordinator
    weak var webView: WKWebView?

    init(_ webView: WKWebView){
        self.webView = webView
    }

    public func setGraph(_ nodes: Set<GraphKitNode>) {

    }
    
    public func onNodeClick(nodeAction: GraphKitNodeEvent) {

    }
}


class D3GraphKitCoordinator: NSObject, WKNavigationDelegate, WKScriptMessageHandler {
    weak var webView: WKWebView?


    func webView(_ webView: WKWebView, didFinish navigation: WKNavigation!) {
        self.webView = webView
    }

    // receive message from wkwebview
    func userContentController(
        _ userContentController: WKUserContentController,
        didReceive message: WKScriptMessage
    ) {
        guard let body = message.body as? String else {
            print("Not a string")
            return
        }
        do {
            let response = try JSONDecoder().decode(D3PageResponse.self, from: body.data(using: .utf8)!)
        } catch {
            print("Error for js parsing: \(error)")
        }

//        let filteredManifest = processor?.analyzer?.filterManifest(node: response.id)
//        let formattedManifest = processor!.formatter.generate(filteredManifest!, focus: response.id)
//        self.webView?.evaluateJavaScript("webkit.messageHandlers.bridge.onMessage('\(formattedManifest.0)')")
        //            DispatchQueue.main.asyncAfter(deadline: .now() + 1) {
//                self.messageToWebview(msg: "hello, I got your messsage: \(message.body) at \(date)")
//            }
    }

    func select(nodeName: BuildManifestId) {
        let filteredManifest = processor?.analyzer?.filterManifest(node: nodeName)
        let formattedManifest = processor!.formatter.generate(filteredManifest!, focus: nodeName)
        self.webView?.evaluateJavaScript("webkit.messageHandlers.bridge.onMessage('\(formattedManifest.0)')")
    }

    func messageToWebview(msg: String) {
        self.webView?.evaluateJavaScript("webkit.messageHandlers.bridge.onMessage('\(msg)')")
    }
}




class WebViewCoordinator: NSObject, WKNavigationDelegate, WKScriptMessageHandler {
    var webView: WKWebView?
    var processor: Processor?

    func setProcessor(_ processor: Processor) {
        self.processor = processor
    }

    func webView(_ webView: WKWebView, didFinish navigation: WKNavigation!) {
        self.webView = webView
    }

    // receive message from wkwebview
    func userContentController(
        _ userContentController: WKUserContentController,
        didReceive message: WKScriptMessage
    ) {
        guard let body = message.body as? String else {
            print("Not a string")
            return
        }
        struct Response: Decodable {
            let msg: String
            let id: String
        }
//            print(message.body)
        let response = try! JSONDecoder().decode(Response.self, from: body.data(using: .utf8)!)

        let filteredManifest = processor?.analyzer?.filterManifest(node: response.id)
        let formattedManifest = processor!.formatter.generate(filteredManifest!, focus: response.id)
        self.webView?.evaluateJavaScript("webkit.messageHandlers.bridge.onMessage('\(formattedManifest.0)')")
        //            DispatchQueue.main.asyncAfter(deadline: .now() + 1) {
//                self.messageToWebview(msg: "hello, I got your messsage: \(message.body) at \(date)")
//            }
    }

    func select(nodeName: BuildManifestId) {
        let filteredManifest = processor?.analyzer?.filterManifest(node: nodeName)
        let formattedManifest = processor!.formatter.generate(filteredManifest!, focus: nodeName)
        self.webView?.evaluateJavaScript("webkit.messageHandlers.bridge.onMessage('\(formattedManifest.0)')")
    }

    func messageToWebview(msg: String) {
        self.webView?.evaluateJavaScript("webkit.messageHandlers.bridge.onMessage('\(msg)')")
    }
}


class GraphProcessor {
//    var parser = BuildManifestParser()
//    var formatter = BuildManifestFormatter()
//    var analyzer: BuildGraphAnalyzer?
}

struct GraphWebView: NSViewRepresentable {
    let coordinator = WebViewCoordinator()
    let processor = GraphProcessor()



    func makeCoordinator() -> Coordinator {
        coordinator.setProcessor(processor)
        return coordinator
    }

    func makeNSView(context: Context) -> WKWebView {
        let coordinator = makeCoordinator()
        let userContentController = WKUserContentController()
        userContentController.add(coordinator, name: "bridge")

        let configuration = WKWebViewConfiguration()
        configuration.userContentController = userContentController

        let _wkwebview = WKWebView(frame: .zero, configuration: configuration)
        _wkwebview.navigationDelegate = coordinator
        if #available(macOS 13.3, *) {
            _wkwebview.isInspectable = true
        }

        return _wkwebview
    }

    func updateNSView(_ webView: WKWebView, context: Context) {
//        let path: String = "\(Bundle.main.bundlePath)/Contents/Resources/@hpcc-js/wasm@/index.html"// .path(forResource: "index", ofType: "html") else { return }
        guard let path: String = Bundle.main.path(forResource: "index", ofType: "html") else { return }
        let localHTMLUrl = URL(fileURLWithPath: path, isDirectory: false)
        let html = try! String(contentsOf: localHTMLUrl)
//        webView.loadHTMLString(html, baseURL: localHTMLUrl.deletingLastPathComponent())
        var resources = localHTMLUrl.deletingLastPathComponent()//.appending(component: "@hpcc-js").appending(component: "wasm@/")
        webView.loadFileURL(localHTMLUrl, allowingReadAccessTo: resources)
    }

    func send(_ text: String) {
        let compl = { i, e in
            print(i)
            print(e)
        }

        coordinator.webView?.evaluateJavaScript("webkit.messageHandlers.bridge.onMessage(\"\(text)\")" , completionHandler: compl)
    }

    func rebuild() -> BuildManifest {
        do {
//            let path =  "\(URL(string:#file)!.deletingLastPathComponent())../ManifestParserTests/Fixtures/sampleManifest.json"

            let pathURL = Bundle.main.url(forResource: "sampleManifest", withExtension: "json")
            let path = pathURL!.absoluteURL.path
            let manifest = try processor.parser.process(path)
            let graph = processor.formatter.generate(manifest, limit: 40, focus: nil)
            processor.analyzer = BuildGraphAnalyzer(manifest, mapping: graph.1)
//            var analyzer = BuildGraphAnalyzer(manifest)
//            analyzer.vicinityEdges(node: )
//            processor.formatter.generate(BuildManifest, limit: <#T##Int#>)
//            print(graph)
            send(graph.0.replacingOccurrences(of: "\"", with: "\\\""))
            return manifest
        } catch {
            print(error)
            return BuildManifest(commands: [:])
        }
    }
}
